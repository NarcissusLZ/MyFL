import torchimport numpy as npfrom torch.utils.data import DataLoaderimport copyimport torch.nn as nnimport randomclass Server:    def __init__(self, config, test_dataset):        self.config = config        self.device = self._select_device(config['device'])        # 初始化全局模型        self.global_model = self.init_model()        self.global_model.to(self.device)        # 准备测试数据集        self.test_loader = DataLoader(            test_dataset,            batch_size=config['test_batch_size'],            shuffle=False        )        # 添加通信量统计        self.total_down_communication = 0  # 下行通信总量（字节）        self.total_up_communication = 0  # 上行通信总量（字节）        self.round_down_communication = 0  # 当前轮次下行通信量        self.round_up_communication = 0  # 当前轮次上行通信量        self.communication_history = []  # 每轮通信量记录        # 记录聚合权重        self.client_weights = {}        print(f"服务器初始化完成, 设备: {self.device}")    def get_model_size(self):        """计算模型参数大小（字节）"""        size_bytes = 0        for param in self.global_model.parameters():            # 每个参数元素占用4字节（float32）            size_bytes += param.nelement() * 4        return size_bytes    def init_model(self):        print("服务器开始初始化模型...")        if self.config['model'] == 'VGG16' and self.config['dataset'] == 'cifar10':            from models.vgg16 import CIFAR10_VGG16            return CIFAR10_VGG16(num_classes=10)        elif self.config['model'] == 'VGG16' and self.config['dataset'] == 'cifar100':            from models.vgg16 import CIFAR100_VGG16            return CIFAR100_VGG16(num_classes=100)        elif self.config['model'] == 'RESNET18' and self.config['dataset'] == 'cifar10':            from models.resnet18 import CIFAR10_ResNet18            return CIFAR10_ResNet18(num_classes=10)        elif self.config['model'] == 'RESNET18' and self.config['dataset'] == 'cifar100':            from models.resnet18 import CIFAR100_ResNet18            return CIFAR100_ResNet18(num_classes=100)        elif self.config['model'] == 'RESNET50' and self.config['dataset'] == 'cifar10':            from models.resnet50 import CIFAR10_ResNet50            return CIFAR10_ResNet50(num_classes=10)        elif self.config['model'] == 'RESNET50' and self.config['dataset'] == 'cifar100':            from models.resnet50 import CIFAR100_ResNet50            return CIFAR100_ResNet50(num_classes=100)        else:            raise ValueError(f"未知模型: {self.config['model']}")    def _select_device(self, device_config):        """选择设备"""        if device_config == 'cuda' and torch.cuda.is_available():            return torch.device('cuda')        elif device_config == 'mps' and torch.backends.mps.is_available():            return torch.device('mps')        else:            return torch.device('cpu')    def broadcast_model(self, selected_clients):        """向选中的客户端广播最新的全局模型参数"""        print("服务器广播全局模型参数...")        # 计算模型大小和总下行通信量        model_size = self.get_model_size()        round_down_communication = model_size * len(selected_clients)        self.total_down_communication += round_down_communication        self.round_down_communication = round_down_communication        print(f"模型大小: {model_size / 1024 / 1024:.2f} MB")        print(f"本轮下行通信量: {round_down_communication / 1024 / 1024:.2f} MB")        global_state_dict = copy.deepcopy(self.global_model.state_dict())        model_class = self.global_model.__class__  # 获取模型类        for client in selected_clients:            client.receive_model(model_class, global_state_dict)        print(f"已向 {len(selected_clients)} 个客户端广播模型参数")    def select_clients(self, all_clients, fraction=0.1):        """选择参与本轮训练的客户端"""        num_selected = max(1, int(fraction * len(all_clients)))        selected_clients = np.random.choice(            all_clients,            num_selected,            replace=False        )        print(f"本轮选中 {num_selected} 个客户端")        return selected_clients    def receive_local_model(self, client_id, model_state_dict, num_samples):        """接收客户端上传的模型更新，模拟一定概率的丢包情况"""        # 获取丢包率，如果配置中没有设置，默认为0（不丢包）        packet_loss_rate = self.config.get('packet_loss_rate', 0.0)        # 获取需要丢弃的层名称列表，如果配置中没有设置，默认为空列表（不指定层）        layers_to_drop = self.config.get('layers_to_drop', [])        # 按层存储客户端的更新        if client_id not in self.client_weights:            self.client_weights[client_id] = {                'state_dict': {},                'num_samples': num_samples            }        # 计算上行通信量（初始设为0）        received_model_size = 0        # 整体决定是否丢弃指定的层        should_drop_packet = random.random() < packet_loss_rate        # 遍历模型的每一层        for key, param in model_state_dict.items():            # 判断当前层是否在要丢弃的列表中            is_target_layer = False            if layers_to_drop:                for layer_pattern in layers_to_drop:                    if layer_pattern in key:                        is_target_layer = True                        break            # 如果是目标层且决定丢弃，则跳过该层            if is_target_layer and should_drop_packet:                continue            # 否则保存该层并计算通信量            self.client_weights[client_id]['state_dict'][key] = copy.deepcopy(param)            layer_size = param.nelement() * 4  # float32 = 4字节            received_model_size += layer_size        # 如果决定丢弃且有目标层，打印丢包信息        if should_drop_packet and layers_to_drop:            print(f"⚠️ 模拟网络丢包：客户端 {client_id} 的所有指定层 {layers_to_drop} 更新被丢弃")        # 更新通信量统计        self.total_up_communication += received_model_size        self.round_up_communication += received_model_size        # 检查是否有任何层被成功接收        if not self.client_weights[client_id]['state_dict']:            print(f"客户端 {client_id} 的所有层都被丢弃，无法使用该客户端的更新")            # 删除该客户端的记录            del self.client_weights[client_id]            return False        print(f"服务器已接收客户端 {client_id} 的部分更新，接收数据量: {received_model_size / 1024 / 1024:.2f} MB")        return True    def test_model(self):        """在测试集上评估全局模型"""        print("开始模型测试...")        self.global_model.eval()        test_loss = 0        correct = 0        total = 0        with torch.no_grad():            for data, target in self.test_loader:                data, target = data.to(self.device), target.to(self.device)                output = self.global_model(data)                # 计算损失                test_loss += nn.CrossEntropyLoss()(output, target).item()                # 计算准确率                pred = output.argmax(dim=1, keepdim=True)                correct += pred.eq(target.view_as(pred)).sum().item()                total += target.size(0)        avg_loss = test_loss / len(self.test_loader)        accuracy = 100. * correct / total        print(f"测试结果 | 损失: {avg_loss:.4f} | 准确率: {accuracy:.2f}%")        return {'loss': avg_loss, 'accuracy': accuracy}    def next_round(self):        """准备下一轮训练"""        # 记录本轮通信量        self.communication_history.append({            'down_communication': self.round_down_communication / (1024 * 1024),  # MB            'up_communication': self.round_up_communication / (1024 * 1024),  # MB            'total_communication': (self.round_down_communication + self.round_up_communication) / (1024 * 1024)  # MB        })        # 重置本轮通信量统计        self.round_down_communication = 0        self.round_up_communication = 0        # 清除客户端权重        self.client_weights = {}    def get_communication_stats(self):        """获取通信统计信息"""        return {            "总下行通信量(MB)": self.total_down_communication / (1024 * 1024),            "总上行通信量(MB)": self.total_up_communication / (1024 * 1024),            "总通信量(MB)": (self.total_down_communication + self.total_up_communication) / (1024 * 1024),            "每轮通信量记录": self.communication_history        }